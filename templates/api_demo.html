<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Quran Recitation API Demo - All Endpoints</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: white;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            display: grid;
            grid-template-columns: 1fr 2fr 1fr;
            gap: 20px;
        }

        .panel {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 20px;
            padding: 20px;
            backdrop-filter: blur(10px);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
        }

        h1, h2 {
            margin-bottom: 20px;
        }

        h1 {
            grid-column: 1 / -1;
            text-align: center;
            font-size: 2.5em;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
        }

        .btn {
            padding: 10px 20px;
            border: none;
            border-radius: 25px;
            font-size: 14px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            margin: 5px;
            width: calc(100% - 10px);
        }

        .btn-primary {
            background: linear-gradient(45deg, #4CAF50, #45a049);
            color: white;
        }

        .btn-danger {
            background: linear-gradient(45deg, #f44336, #da190b);
            color: white;
        }

        .btn-secondary {
            background: linear-gradient(45deg, #2196F3, #0b7dda);
            color: white;
        }

        .btn-warning {
            background: linear-gradient(45deg, #ff9800, #f57c00);
            color: white;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
        }

        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        select, input {
            width: 100%;
            padding: 10px;
            margin: 5px 0;
            border-radius: 10px;
            border: none;
            background: rgba(255, 255, 255, 0.9);
            color: #333;
        }

        .status-badge {
            display: inline-block;
            padding: 5px 10px;
            border-radius: 15px;
            font-size: 12px;
            font-weight: bold;
            margin: 2px;
        }

        .status-active {
            background: #4CAF50;
        }

        .status-inactive {
            background: #f44336;
        }

        .status-pending {
            background: #ff9800;
        }

        .word {
            display: inline-block;
            padding: 5px 8px;
            margin: 2px;
            border-radius: 8px;
            transition: all 0.3s ease;
            cursor: pointer;
            font-size: 20px;
            direction: rtl;
        }

        .word.current {
            background: rgba(255, 255, 0, 0.3);
            transform: scale(1.1);
            box-shadow: 0 0 10px rgba(255, 255, 0, 0.5);
        }

        .word.correct {
            background: rgba(76, 175, 80, 0.8);
            color: white;
        }

        .word.partial {
            background: rgba(255, 193, 7, 0.8);
            color: white;
        }

        .word.incorrect {
            background: rgba(244, 67, 54, 0.8);
            color: white;
        }

        .word.next-expected {
            background: rgba(33, 150, 243, 0.5);
            color: white;
            animation: pulse 1.5s infinite;
        }

        @keyframes pulse {
            0%, 100% {
                transform: scale(1);
                box-shadow: 0 0 5px rgba(33, 150, 243, 0.5);
            }
            50% {
                transform: scale(1.05);
                box-shadow: 0 0 15px rgba(33, 150, 243, 0.8);
            }
        }

        .reference-text {
            background: rgba(255, 255, 255, 0.1);
            padding: 20px;
            border-radius: 15px;
            margin: 20px 0;
            min-height: 200px;
            font-size: 24px;
            line-height: 1.8;
            text-align: right;
            direction: rtl;
            font-family: 'Amiri', 'Times New Roman', serif;
        }

        .api-response {
            background: rgba(0, 0, 0, 0.3);
            padding: 10px;
            border-radius: 10px;
            margin: 10px 0;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            max-height: 200px;
            overflow-y: auto;
        }

        .progress-bar {
            width: 100%;
            height: 20px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 10px;
            overflow: hidden;
            margin: 10px 0;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #4CAF50, #8BC34A);
            width: 0%;
            transition: width 0.3s ease;
        }

        .section {
            margin: 20px 0;
            padding: 15px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 10px;
        }

        .section h3 {
            margin-bottom: 10px;
            font-size: 1.1em;
            color: #FFC107;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }

        .stat-item {
            background: rgba(255, 255, 255, 0.1);
            padding: 10px;
            border-radius: 10px;
            text-align: center;
        }

        .stat-value {
            font-size: 24px;
            font-weight: bold;
            color: #4CAF50;
        }

        .stat-label {
            font-size: 12px;
            opacity: 0.8;
        }

        .color-input-group {
            display: flex;
            align-items: center;
            margin: 5px 0;
        }

        .color-input-group label {
            flex: 1;
            font-size: 14px;
        }

        .color-input-group input[type="color"] {
            width: 60px;
            height: 30px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }

        #audioVisualizer {
            width: 100%;
            height: 100px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            margin: 10px 0;
        }

        .latency-options {
            display: flex;
            gap: 10px;
            margin: 10px 0;
        }

        .latency-option {
            flex: 1;
            padding: 10px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s;
        }

        .latency-option.active {
            background: rgba(76, 175, 80, 0.3);
            transform: scale(1.05);
        }

        .export-buttons {
            display: flex;
            gap: 10px;
            margin: 10px 0;
        }

        .log-entry {
            padding: 5px;
            margin: 2px 0;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 5px;
            font-size: 11px;
        }

        .log-entry.success {
            border-left: 3px solid #4CAF50;
        }

        .log-entry.error {
            border-left: 3px solid #f44336;
        }

        .log-entry.info {
            border-left: 3px solid #2196F3;
        }

        /* Mode selector styles */
        .mode-selector {
            margin-bottom: 20px;
            padding: 15px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
        }

        .mode-option {
            padding: 15px;
            margin: 10px 0;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .mode-option:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: translateX(5px);
        }

        .mode-option.active {
            background: rgba(76, 175, 80, 0.3);
            border: 2px solid #4CAF50;
        }

        .language-toggle {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }

        .language-option {
            flex: 1;
            padding: 10px;
            text-align: center;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s;
        }

        .language-option.active {
            background: rgba(33, 150, 243, 0.3);
            border: 1px solid #2196F3;
        }

        /* Hide duplicate mode selector */
        #analysisModeSelect {
            display: none;
        }

        /* Analysis related styles */
        .reference-text-input {
            display: none;
            width: 100%;
            min-height: 150px;
            padding: 15px;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 10px;
            font-size: 18px;
            direction: rtl;
            font-family: 'Amiri', serif;
        }

        .reference-text-input.show {
            display: block;
        }

        .analysis-button {
            display: none;
            width: 100%;
            margin: 15px 0;
        }

        .analysis-button.show {
            display: block;
        }

        .analysis-results {
            display: none;
            background: rgba(255, 255, 255, 0.1);
            padding: 20px;
            border-radius: 10px;
            margin-top: 20px;
        }

        .analysis-results.show {
            display: block;
        }

        .audio-feedback-player {
            display: none;
            margin-top: 15px;
            padding: 15px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 10px;
        }

        .audio-feedback-player.show {
            display: block;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üïå Quran Recitation API Demo - Testing ALL Endpoints</h1>

        <!-- Left Panel: Session & Surah Management -->
        <div class="panel">
            <h2>üìö Control Panel</h2>

            <!-- New Mode Selection -->
            <div class="mode-selector">
                <h3>Analysis Mode</h3>
                <div class="mode-option active" data-mode="live" onclick="switchAnalysisMode('live')">
                    <span>üéôÔ∏è Live Transcription</span>
                    <span>‚ñ∂</span>
                </div>
                <div class="mode-option" data-mode="tajweed" onclick="switchAnalysisMode('tajweed')">
                    <span>üìñ Tajweed Analysis</span>
                    <span>‚ñ∂</span>
                </div>
                <div class="mode-option" data-mode="recitation" onclick="switchAnalysisMode('recitation')">
                    <span>‚úÖ Recitation Check</span>
                    <span>‚ñ∂</span>
                </div>

                <!-- Language Toggle (for GPT modes) -->
                <div class="language-toggle" id="languageToggle" style="display: none;">
                    <div class="language-option active" data-lang="en" onclick="setAnalysisLanguage('en')">
                        üá¨üáß English
                    </div>
                    <div class="language-option" data-lang="ar" onclick="setAnalysisLanguage('ar')">
                        üá∏üá¶ ÿßŸÑÿπÿ±ÿ®Ÿäÿ©
                    </div>
                </div>
            </div>

            <div class="section">
                <h3>Surah Management</h3>
                <button class="btn btn-secondary" onclick="getAllSurahs()">Get All Surahs</button>
                <button class="btn btn-secondary" onclick="searchSurahs()">Search Surahs</button>
                <input type="text" id="searchQuery" placeholder="Search query...">

                <select id="surahSelect">
                    <option value="">Loading surahs...</option>
                </select>

                <button class="btn btn-primary" onclick="getSurahDetails()">Get Surah Details</button>
            </div>

            <div class="section">
                <h3>Analysis Mode</h3>
                <select id="analysisModeSelect" onchange="setAnalysisMode(this.value)" style="width: 100%; padding: 10px; margin-bottom: 10px; background: rgba(255,255,255,0.1); color: white; border: 1px solid rgba(255,255,255,0.3); border-radius: 5px;">
                    <option value="live">üé§ Live Transcription (Real-time)</option>
                    <option value="gpt-recitation">üìù Recitation Analysis (GPT Audio)</option>
                    <option value="gpt-tajweed">üìø Tajweed Analysis (GPT Audio)</option>
                </select>
            </div>

            <div class="section">
                <h3>Session Control</h3>

                <div class="latency-options" id="latencyOptions">
                    <div class="latency-option active" data-mode="instant">
                        ‚ö° Instant
                    </div>
                    <div class="latency-option" data-mode="balanced">
                        ‚öñÔ∏è Balanced
                    </div>
                    <div class="latency-option" data-mode="accurate">
                        üéØ Accurate
                    </div>
                </div>

                <button class="btn btn-primary" id="startBtn" onclick="startSession()">
                    üé§ Start Session
                </button>
                <button class="btn btn-warning" id="pauseBtn" onclick="pauseSession()" disabled>
                    ‚è∏Ô∏è Pause Session
                </button>
                <button class="btn btn-primary" id="resumeBtn" onclick="resumeSession()" disabled>
                    ‚ñ∂Ô∏è Resume Session
                </button>
                <button class="btn btn-danger" id="stopBtn" onclick="stopSession()" disabled>
                    ‚èπÔ∏è Stop Session
                </button>
                <button class="btn btn-secondary" id="resetBtn" onclick="resetSession()">
                    üîÑ Reset Session
                </button>

                <div class="api-response" id="sessionInfo">
                    Session ID: <span id="currentSessionId">None</span><br>
                    Status: <span class="status-badge status-inactive">Inactive</span>
                </div>
            </div>

            <div class="section">
                <h3>Session Management</h3>
                <button class="btn btn-secondary" onclick="getAllSessions()">Get All Sessions</button>
                <button class="btn btn-secondary" onclick="getSessionProgress()">Get Progress</button>
                <div class="api-response" id="sessionsListResponse"></div>
            </div>
        </div>

        <!-- Center Panel: Main Display & Audio -->
        <div class="panel">
            <h2 id="centerPanelTitle">üéôÔ∏è Recitation Area</h2>

            <!-- Mode Instructions -->
            <div class="mode-instructions" id="modeInstructions">
                <strong>Live Transcription Mode:</strong> Start a session and begin reciting. Real-time feedback will appear as you speak.
            </div>

            <div class="progress-bar">
                <div class="progress-fill" id="progressFill"></div>
            </div>

            <div class="stats-grid">
                <div class="stat-item">
                    <div class="stat-value" id="currentWordStat">0</div>
                    <div class="stat-label">Current Word</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="totalWordsStat">0</div>
                    <div class="stat-label">Total Words</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="accuracyStat">0%</div>
                    <div class="stat-label">Accuracy</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="timeStat">0:00</div>
                    <div class="stat-label">Duration</div>
                </div>
            </div>

            <div class="reference-text" id="referenceText">
                Select a surah and start a session to begin...
            </div>

            <!-- Reference Text Input for Recitation Mode -->
            <textarea
                class="reference-text-input"
                id="referenceTextInput"
                placeholder="Enter the Arabic reference text for recitation checking...">
            </textarea>

            <!-- Analysis Button for GPT Modes -->
            <button class="btn btn-primary analysis-button" id="analysisButton" onclick="performAnalysis()">
                üîç Analyze Audio
            </button>

            <!-- Analysis Results Display -->
            <div class="analysis-results" id="analysisResults">
                <h3>Analysis Results</h3>
                <div id="analysisContent"></div>
            </div>

            <!-- Audio Feedback Player -->
            <div class="audio-feedback-player" id="audioFeedbackPlayer">
                <h4>Audio Feedback</h4>
                <audio id="feedbackAudio" controls style="width: 100%;"></audio>
            </div>

            <div class="section">
                <h3>Audio Input</h3>
                <button class="btn btn-primary" id="recordBtn" onclick="toggleRecording()">
                    üé§ Start Recording
                </button>
                <button class="btn btn-danger" onclick="stopRecording()" disabled id="stopRecordingBtn">
                    ‚èπÔ∏è Stop Recording
                </button>

                <input type="file" id="audioFile" accept="audio/*" style="margin: 10px 0;">
                <button class="btn btn-secondary" onclick="uploadAudioFile()">
                    üì§ Upload Audio File
                </button>

                <canvas id="audioVisualizer"></canvas>

                <!-- Surah Context for GPT Modes -->
                <div id="surahContext" style="display: none; margin-top: 15px;">
                    <input type="text" id="contextSurah" placeholder="Surah name (optional)" style="margin: 5px 0;">
                    <input type="number" id="contextAyah" placeholder="Ayah number (optional)" min="1" style="margin: 5px 0;">
                </div>

                <div class="api-response" id="audioResponse">
                    Audio feedback will appear here...
                </div>
            </div>

            <div class="section">
                <h3>Feedback History</h3>
                <button class="btn btn-secondary" onclick="getFeedbackHistory()">
                    Get History
                </button>
                <button class="btn btn-secondary" onclick="getFeedbackSummary()">
                    Get Summary
                </button>
                <div class="api-response" id="feedbackHistoryResponse"></div>
            </div>
        </div>

        <!-- Right Panel: Settings & Advanced -->
        <div class="panel">
            <h2>‚öôÔ∏è Settings & Stats</h2>

            <div class="section">
                <h3>UI Settings</h3>
                <button class="btn btn-secondary" onclick="getUISettings()">
                    Get Current Settings
                </button>

                <div class="color-input-group">
                    <label>Correct:</label>
                    <input type="color" id="colorCorrect" value="#4CAF50">
                </div>
                <div class="color-input-group">
                    <label>Partial:</label>
                    <input type="color" id="colorPartial" value="#FFC107">
                </div>
                <div class="color-input-group">
                    <label>Incorrect:</label>
                    <input type="color" id="colorIncorrect" value="#f44336">
                </div>
                <div class="color-input-group">
                    <label>Next Expected:</label>
                    <input type="color" id="colorNext" value="#2196F3">
                </div>
                <div class="color-input-group">
                    <label>Current:</label>
                    <input type="color" id="colorCurrent" value="#FFFF00">
                </div>

                <button class="btn btn-primary" onclick="updateColorScheme()">
                    üé® Apply Colors
                </button>

                <label>Font Size:</label>
                <input type="range" id="fontSize" min="16" max="36" value="24">

                <label>
                    <input type="checkbox" id="showHints" checked> Show Hints
                </label>
                <label>
                    <input type="checkbox" id="showTajweed" checked> Show Tajweed
                </label>

                <button class="btn btn-primary" onclick="updateUISettings()">
                    üíæ Save UI Settings
                </button>
            </div>

            <div class="section">
                <h3>Learning & Progress</h3>
                <input type="text" id="userId" placeholder="User ID" value="test_user">

                <button class="btn btn-secondary" onclick="getLearningStats()">
                    üìä Get Learning Stats
                </button>
                <button class="btn btn-secondary" onclick="getRecommendations()">
                    üí° Get Recommendations
                </button>
                <button class="btn btn-secondary" onclick="getOverallProgress()">
                    üìà Overall Progress
                </button>
                <button class="btn btn-secondary" onclick="getSurahProgress()">
                    üìâ Surah Progress
                </button>

                <div class="api-response" id="learningStatsResponse"></div>
            </div>

            <div class="section">
                <h3>Export & Tools</h3>
                <div class="export-buttons">
                    <button class="btn btn-secondary" onclick="exportSession('json')">
                        üìÑ Export JSON
                    </button>
                    <button class="btn btn-secondary" onclick="exportSession('csv')">
                        üìä Export CSV
                    </button>
                </div>

                <button class="btn btn-warning" onclick="checkHealth()">
                    üè• Health Check
                </button>

                <button class="btn btn-secondary" onclick="setFeedbackMode()">
                    üéØ Change Feedback Mode
                </button>
            </div>

            <div class="section">
                <h3>API Log</h3>
                <div class="api-response" id="apiLog" style="max-height: 300px;">
                    <div class="log-entry info">API Ready. Waiting for actions...</div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Configuration
        const API_BASE = 'http://localhost:8001';
        let currentSessionId = null;
        let ws = null;
        let mediaRecorder = null;
        let audioChunks = [];
        let isRecording = false;
        let sessionStartTime = null;
        let sessionTimer = null;

        // New GPT Audio Analysis variables
        let currentAnalysisMode = 'live';  // 'live', 'tajweed', 'recitation'
        let analysisLanguage = 'en';  // 'en' or 'ar'
        let currentAudioBlob = null;

        // Logging helper
        function log(message, type = 'info') {
            const logDiv = document.getElementById('apiLog');
            const entry = document.createElement('div');
            entry.className = `log-entry ${type}`;
            const timestamp = new Date().toLocaleTimeString();
            entry.textContent = `[${timestamp}] ${message}`;
            logDiv.insertBefore(entry, logDiv.firstChild);

            // Keep only last 50 entries
            while (logDiv.children.length > 50) {
                logDiv.removeChild(logDiv.lastChild);
            }
        }

        // 1. SURAH MANAGEMENT ENDPOINTS
        async function getAllSurahs() {
            log('Calling GET /api/surahs...');
            try {
                const response = await fetch(`${API_BASE}/api/surahs`);
                const surahs = await response.json();

                const select = document.getElementById('surahSelect');
                select.innerHTML = '<option value="">Select a Surah...</option>';

                surahs.forEach(surah => {
                    const option = document.createElement('option');
                    option.value = surah.number;
                    option.textContent = `${surah.number}. ${surah.name} (${surah.english_name})`;
                    option.dataset.surahData = JSON.stringify(surah);
                    select.appendChild(option);
                });

                log(`Loaded ${surahs.length} surahs`, 'success');
            } catch (error) {
                log(`Error loading surahs: ${error.message}`, 'error');
            }
        }

        async function getSurahDetails() {
            const surahNumber = document.getElementById('surahSelect').value;
            if (!surahNumber) {
                log('Please select a surah first', 'error');
                return;
            }

            log(`Calling GET /api/surahs/${surahNumber}...`);
            try {
                const response = await fetch(`${API_BASE}/api/surahs/${surahNumber}`);
                const surah = await response.json();

                displaySurahText(surah);
                log(`Loaded details for ${surah.name}`, 'success');
            } catch (error) {
                log(`Error loading surah details: ${error.message}`, 'error');
            }
        }

        async function searchSurahs() {
            const query = document.getElementById('searchQuery').value;
            if (!query) {
                log('Please enter a search query', 'error');
                return;
            }

            log(`Calling GET /api/surahs/search?query=${query}...`);
            try {
                const response = await fetch(`${API_BASE}/api/surahs/search?query=${encodeURIComponent(query)}`);
                const results = await response.json();

                log(`Found ${results.length} matching surahs`, 'success');

                // Update select with search results
                const select = document.getElementById('surahSelect');
                select.innerHTML = '<option value="">Search Results:</option>';
                results.forEach(surah => {
                    const option = document.createElement('option');
                    option.value = surah.number;
                    option.textContent = `${surah.number}. ${surah.name} (${surah.english_name})`;
                    select.appendChild(option);
                });
            } catch (error) {
                log(`Error searching surahs: ${error.message}`, 'error');
            }
        }

        // 2. SESSION MANAGEMENT ENDPOINTS
        async function startSession() {
            const surahNumber = document.getElementById('surahSelect').value;
            if (!surahNumber) {
                log('Please select a surah first', 'error');
                return;
            }

            const latencyMode = document.querySelector('.latency-option.active').dataset.mode;

            log('Calling POST /api/sessions/start...');
            try {
                const response = await fetch(`${API_BASE}/api/sessions/start`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        surah_number: parseInt(surahNumber),
                        latency_mode: latencyMode,
                        enable_tajweed: document.getElementById('showTajweed').checked,
                        enable_hints: document.getElementById('showHints').checked,
                        difficulty_level: 2
                    })
                });

                const data = await response.json();
                currentSessionId = data.session_id;

                document.getElementById('currentSessionId').textContent = currentSessionId;
                document.querySelector('.status-badge').className = 'status-badge status-active';
                document.querySelector('.status-badge').textContent = 'Active';

                displaySurahText(data.surah);
                document.getElementById('totalWordsStat').textContent = data.total_words;

                // Enable/disable buttons
                document.getElementById('startBtn').disabled = true;
                document.getElementById('pauseBtn').disabled = false;
                document.getElementById('stopBtn').disabled = false;

                // Connect WebSocket
                connectWebSocket();

                // Start timer
                sessionStartTime = Date.now();
                startSessionTimer();

                log(`Session started: ${currentSessionId}`, 'success');
            } catch (error) {
                log(`Error starting session: ${error.message}`, 'error');
            }
        }

        async function pauseSession() {
            if (!currentSessionId) {
                log('No active session', 'error');
                return;
            }

            log(`Calling POST /api/sessions/${currentSessionId}/pause...`);
            try {
                const response = await fetch(`${API_BASE}/api/sessions/${currentSessionId}/pause`, {
                    method: 'POST'
                });
                const data = await response.json();

                document.getElementById('pauseBtn').disabled = true;
                document.getElementById('resumeBtn').disabled = false;
                document.querySelector('.status-badge').textContent = 'Paused';

                log('Session paused', 'success');
            } catch (error) {
                log(`Error pausing session: ${error.message}`, 'error');
            }
        }

        async function resumeSession() {
            if (!currentSessionId) {
                log('No active session', 'error');
                return;
            }

            log(`Calling POST /api/sessions/${currentSessionId}/resume...`);
            try {
                const response = await fetch(`${API_BASE}/api/sessions/${currentSessionId}/resume`, {
                    method: 'POST'
                });
                const data = await response.json();

                document.getElementById('pauseBtn').disabled = false;
                document.getElementById('resumeBtn').disabled = true;
                document.querySelector('.status-badge').textContent = 'Active';

                log('Session resumed', 'success');
            } catch (error) {
                log(`Error resuming session: ${error.message}`, 'error');
            }
        }

        async function stopSession() {
            if (!currentSessionId) {
                log('No active session', 'error');
                return;
            }

            log(`Calling POST /api/sessions/${currentSessionId}/stop...`);
            try {
                const response = await fetch(`${API_BASE}/api/sessions/${currentSessionId}/stop`, {
                    method: 'POST'
                });
                const data = await response.json();

                document.getElementById('startBtn').disabled = false;
                document.getElementById('pauseBtn').disabled = true;
                document.getElementById('resumeBtn').disabled = true;
                document.getElementById('stopBtn').disabled = true;
                document.querySelector('.status-badge').className = 'status-badge status-inactive';
                document.querySelector('.status-badge').textContent = 'Stopped';

                if (ws) {
                    ws.close();
                }

                clearInterval(sessionTimer);

                log(`Session stopped. Duration: ${data.duration}s, Accuracy: ${data.final_accuracy}`, 'success');
            } catch (error) {
                log(`Error stopping session: ${error.message}`, 'error');
            }
        }

        async function resetSession() {
            if (!currentSessionId) {
                log('No active session', 'error');
                return;
            }

            log(`Calling POST /api/sessions/${currentSessionId}/reset...`);
            try {
                const response = await fetch(`${API_BASE}/api/sessions/${currentSessionId}/reset`, {
                    method: 'POST'
                });
                const data = await response.json();

                // Reset UI
                document.getElementById('currentWordStat').textContent = '0';
                document.getElementById('accuracyStat').textContent = '0%';
                document.getElementById('progressFill').style.width = '0%';

                // Clear word highlighting
                document.querySelectorAll('.word').forEach(word => {
                    word.className = 'word';
                });

                log('Session reset', 'success');
            } catch (error) {
                log(`Error resetting session: ${error.message}`, 'error');
            }
        }

        async function getSessionProgress() {
            if (!currentSessionId) {
                log('No active session', 'error');
                return;
            }

            log(`Calling GET /api/sessions/${currentSessionId}...`);
            try {
                const response = await fetch(`${API_BASE}/api/sessions/${currentSessionId}`);
                const progress = await response.json();

                document.getElementById('currentWordStat').textContent = progress.current_position;
                document.getElementById('accuracyStat').textContent = `${Math.round(progress.accuracy * 100)}%`;
                document.getElementById('progressFill').style.width = `${progress.progress_percentage}%`;

                log(`Progress: ${progress.current_position}/${progress.total_words} (${progress.progress_percentage.toFixed(1)}%)`, 'info');
            } catch (error) {
                log(`Error getting progress: ${error.message}`, 'error');
            }
        }

        async function getAllSessions() {
            log('Calling GET /api/sessions...');
            try {
                const response = await fetch(`${API_BASE}/api/sessions`);
                const sessions = await response.json();

                const responseDiv = document.getElementById('sessionsListResponse');
                responseDiv.innerHTML = `<strong>Active Sessions (${sessions.length}):</strong><br>`;
                sessions.forEach(session => {
                    responseDiv.innerHTML += `ID: ${session.session_id}<br>Surah: ${session.surah_number}<br>Status: ${session.status}<br><hr>`;
                });

                log(`Found ${sessions.length} active sessions`, 'success');
            } catch (error) {
                log(`Error getting sessions: ${error.message}`, 'error');
            }
        }

        // 3. AUDIO PROCESSING ENDPOINTS
        async function startRecording() {
            log('Starting audio recording...');
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                mediaRecorder = new MediaRecorder(stream);
                audioChunks = [];

                mediaRecorder.ondataavailable = event => {
                    audioChunks.push(event.data);
                };

                mediaRecorder.onstop = async () => {
                    const audioBlob = new Blob(audioChunks, { type: 'audio/webm' });
                    await submitAudioBlob(audioBlob);
                };

                mediaRecorder.start();
                isRecording = true;

                document.getElementById('stopRecordingBtn').disabled = false;
                log('Recording started', 'success');

                // Visualize audio
                visualizeAudio(stream);
            } catch (error) {
                log(`Error starting recording: ${error.message}`, 'error');
            }
        }

        function stopRecording() {
            if (mediaRecorder && isRecording) {
                mediaRecorder.stop();
                isRecording = false;
                document.getElementById('stopRecordingBtn').disabled = true;
                log('Recording stopped', 'info');
            }
        }

        async function submitAudioBlob(blob) {
            if (!currentSessionId) {
                log('No active session for audio submission', 'error');
                return;
            }

            log('Calling POST /api/audio/submit...');
            const formData = new FormData();
            formData.append('audio_file', blob, 'recording.webm');
            formData.append('session_id', currentSessionId);
            formData.append('timestamp', Date.now());

            try {
                const response = await fetch(`${API_BASE}/api/audio/submit`, {
                    method: 'POST',
                    body: formData
                });

                const feedback = await response.json();
                displayAudioFeedback(feedback);
                log('Audio submitted successfully', 'success');
            } catch (error) {
                log(`Error submitting audio: ${error.message}`, 'error');
            }
        }

        async function uploadAudioFile() {
            const fileInput = document.getElementById('audioFile');
            if (!fileInput.files.length) {
                log('Please select an audio file', 'error');
                return;
            }

            if (!currentSessionId) {
                log('No active session', 'error');
                return;
            }

            const file = fileInput.files[0];
            log(`Uploading audio file: ${file.name}...`);

            const formData = new FormData();
            formData.append('audio_file', file);
            formData.append('session_id', currentSessionId);
            formData.append('timestamp', Date.now());

            try {
                const response = await fetch(`${API_BASE}/api/audio/submit`, {
                    method: 'POST',
                    body: formData
                });

                const feedback = await response.json();
                displayAudioFeedback(feedback);
                log('Audio file uploaded successfully', 'success');
            } catch (error) {
                log(`Error uploading file: ${error.message}`, 'error');
            }
        }

        // 4. FEEDBACK ENDPOINTS
        async function getFeedbackHistory() {
            if (!currentSessionId) {
                log('No active session', 'error');
                return;
            }

            log(`Calling GET /api/sessions/${currentSessionId}/feedback/history...`);
            try {
                const response = await fetch(`${API_BASE}/api/sessions/${currentSessionId}/feedback/history?limit=10`);
                const history = await response.json();

                const responseDiv = document.getElementById('feedbackHistoryResponse');
                responseDiv.innerHTML = `<strong>Last ${history.length} feedback items:</strong><br>`;
                history.forEach((item, idx) => {
                    responseDiv.innerHTML += `${idx + 1}. Accuracy: ${(item.overall_accuracy * 100).toFixed(1)}%<br>`;
                });

                log(`Retrieved ${history.length} feedback items`, 'success');
            } catch (error) {
                log(`Error getting feedback history: ${error.message}`, 'error');
            }
        }

        async function getFeedbackSummary() {
            if (!currentSessionId) {
                log('No active session', 'error');
                return;
            }

            log(`Calling GET /api/sessions/${currentSessionId}/feedback/summary...`);
            try {
                const response = await fetch(`${API_BASE}/api/sessions/${currentSessionId}/feedback/summary`);
                const summary = await response.json();

                const responseDiv = document.getElementById('feedbackHistoryResponse');
                responseDiv.innerHTML = `
                    <strong>Session Summary:</strong><br>
                    Total Words: ${summary.total_words_processed}<br>
                    Correct Words: ${summary.correct_words}<br>
                    Accuracy: ${(summary.accuracy * 100).toFixed(1)}%<br>
                `;

                log('Retrieved feedback summary', 'success');
            } catch (error) {
                log(`Error getting feedback summary: ${error.message}`, 'error');
            }
        }

        async function setFeedbackMode() {
            if (!currentSessionId) {
                log('No active session', 'error');
                return;
            }

            const mode = document.querySelector('.latency-option.active').dataset.mode;
            log(`Calling POST /api/feedback/mode...`);

            try {
                const response = await fetch(`${API_BASE}/api/feedback/mode`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        session_id: currentSessionId,
                        mode: mode
                    })
                });

                const result = await response.json();
                log(`Feedback mode changed to: ${result.mode}`, 'success');
            } catch (error) {
                log(`Error setting feedback mode: ${error.message}`, 'error');
            }
        }

        // 5. UI SETTINGS ENDPOINTS
        async function getUISettings() {
            log('Calling GET /api/settings/ui...');
            try {
                const response = await fetch(`${API_BASE}/api/settings/ui`);
                const settings = await response.json();

                document.getElementById('colorCorrect').value = settings.color_scheme.correct;
                document.getElementById('colorPartial').value = settings.color_scheme.partial;
                document.getElementById('colorIncorrect').value = settings.color_scheme.incorrect;
                document.getElementById('colorNext').value = settings.color_scheme.next_expected;
                document.getElementById('colorCurrent').value = settings.color_scheme.current;
                document.getElementById('fontSize').value = settings.font_size;
                document.getElementById('showHints').checked = settings.show_hints;
                document.getElementById('showTajweed').checked = settings.show_tajweed;

                log('UI settings loaded', 'success');
            } catch (error) {
                log(`Error getting UI settings: ${error.message}`, 'error');
            }
        }

        async function updateColorScheme() {
            log('Calling POST /api/settings/colors...');
            const colors = {
                correct: document.getElementById('colorCorrect').value,
                partial: document.getElementById('colorPartial').value,
                incorrect: document.getElementById('colorIncorrect').value,
                next_expected: document.getElementById('colorNext').value,
                current: document.getElementById('colorCurrent').value
            };

            try {
                const response = await fetch(`${API_BASE}/api/settings/colors`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(colors)
                });

                const result = await response.json();
                applyColorScheme(colors);
                log('Color scheme updated', 'success');
            } catch (error) {
                log(`Error updating colors: ${error.message}`, 'error');
            }
        }

        async function updateUISettings() {
            log('Calling POST /api/settings/ui...');
            const settings = {
                color_scheme: {
                    correct: document.getElementById('colorCorrect').value,
                    partial: document.getElementById('colorPartial').value,
                    incorrect: document.getElementById('colorIncorrect').value,
                    next_expected: document.getElementById('colorNext').value,
                    current: document.getElementById('colorCurrent').value
                },
                font_size: parseInt(document.getElementById('fontSize').value),
                show_hints: document.getElementById('showHints').checked,
                show_tajweed: document.getElementById('showTajweed').checked,
                animation_speed: 0.3
            };

            try {
                const response = await fetch(`${API_BASE}/api/settings/ui`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(settings)
                });

                const result = await response.json();
                applyUISettings(settings);
                log('UI settings saved', 'success');
            } catch (error) {
                log(`Error saving UI settings: ${error.message}`, 'error');
            }
        }

        // 6. LEARNING & PROGRESS ENDPOINTS
        async function getLearningStats() {
            const userId = document.getElementById('userId').value;
            log(`Calling GET /api/learning/stats/${userId}...`);

            try {
                const response = await fetch(`${API_BASE}/api/learning/stats/${userId}`);
                const stats = await response.json();

                const responseDiv = document.getElementById('learningStatsResponse');
                responseDiv.innerHTML = `
                    <strong>Learning Stats:</strong><br>
                    Total Sessions: ${stats.total_sessions}<br>
                    Practice Time: ${stats.total_practice_time}h<br>
                    Accuracy Trend: ${JSON.stringify(stats.accuracy_trend)}<br>
                `;

                log('Learning stats retrieved', 'success');
            } catch (error) {
                log(`Error getting learning stats: ${error.message}`, 'error');
            }
        }

        async function getRecommendations() {
            const userId = document.getElementById('userId').value;
            log(`Calling GET /api/learning/recommendations/${userId}...`);

            try {
                const response = await fetch(`${API_BASE}/api/learning/recommendations/${userId}`);
                const recs = await response.json();

                const responseDiv = document.getElementById('learningStatsResponse');
                responseDiv.innerHTML = `<strong>Recommendations:</strong><br>`;
                recs.recommendations.forEach(rec => {
                    responseDiv.innerHTML += `${rec.type}: Surah ${rec.surah} - ${rec.reason}<br>`;
                });

                log('Recommendations retrieved', 'success');
            } catch (error) {
                log(`Error getting recommendations: ${error.message}`, 'error');
            }
        }

        async function getOverallProgress() {
            const userId = document.getElementById('userId').value;
            log(`Calling GET /api/progress/overall/${userId}...`);

            try {
                const response = await fetch(`${API_BASE}/api/progress/overall/${userId}`);
                const progress = await response.json();

                const responseDiv = document.getElementById('learningStatsResponse');
                responseDiv.innerHTML = `
                    <strong>Overall Progress:</strong><br>
                    Surahs Practiced: ${progress.total_surahs_practiced}<br>
                    Practice Time: ${progress.total_practice_time_hours}h<br>
                    Accuracy: ${(progress.overall_accuracy * 100).toFixed(1)}%<br>
                    Streak: ${progress.streak_days} days<br>
                `;

                log('Overall progress retrieved', 'success');
            } catch (error) {
                log(`Error getting overall progress: ${error.message}`, 'error');
            }
        }

        async function getSurahProgress() {
            const userId = document.getElementById('userId').value;
            const surahNumber = document.getElementById('surahSelect').value || 1;
            log(`Calling GET /api/progress/surah/${userId}/${surahNumber}...`);

            try {
                const response = await fetch(`${API_BASE}/api/progress/surah/${userId}/${surahNumber}`);
                const progress = await response.json();

                const responseDiv = document.getElementById('learningStatsResponse');
                responseDiv.innerHTML = `
                    <strong>Surah ${surahNumber} Progress:</strong><br>
                    Completion: ${progress.completion_percentage}%<br>
                    Accuracy: ${(progress.accuracy * 100).toFixed(1)}%<br>
                    Sessions: ${progress.practice_sessions}<br>
                    Last Practiced: ${new Date(progress.last_practiced).toLocaleDateString()}<br>
                `;

                log(`Surah ${surahNumber} progress retrieved`, 'success');
            } catch (error) {
                log(`Error getting surah progress: ${error.message}`, 'error');
            }
        }

        // 7. EXPORT & UTILITY ENDPOINTS
        async function exportSession(format) {
            if (!currentSessionId) {
                log('No active session to export', 'error');
                return;
            }

            log(`Calling GET /api/export/session/${currentSessionId}?format=${format}...`);
            try {
                const response = await fetch(`${API_BASE}/api/export/session/${currentSessionId}?format=${format}`);

                if (format === 'json') {
                    const data = await response.json();
                    downloadJSON(data, `session_${currentSessionId}.json`);
                } else {
                    const blob = await response.blob();
                    downloadBlob(blob, `session_${currentSessionId}.csv`);
                }

                log(`Session exported as ${format.toUpperCase()}`, 'success');
            } catch (error) {
                log(`Error exporting session: ${error.message}`, 'error');
            }
        }

        async function checkHealth() {
            log('Calling GET /health...');
            try {
                const response = await fetch(`${API_BASE}/health`);
                const health = await response.json();

                log(`Health: ${health.status} | Services: Realtime=${health.services.realtime}, Hybrid=${health.services.hybrid}, Metadata=${health.services.metadata}`, 'success');
            } catch (error) {
                log(`Health check failed: ${error.message}`, 'error');
            }
        }

        // 8. WEBSOCKET CONNECTION
        function connectWebSocket() {
            if (!currentSessionId) {
                log('No session ID for WebSocket', 'error');
                return;
            }

            log(`Connecting WebSocket to /ws/${currentSessionId}...`);
            ws = new WebSocket(`ws://localhost:8001/ws/${currentSessionId}`);

            ws.onopen = () => {
                log('WebSocket connected', 'success');
                ws.send(JSON.stringify({ type: 'ping' }));
            };

            ws.onmessage = (event) => {
                const data = JSON.parse(event.data);
                log(`WS Message: ${data.type}`, 'info');
                handleWebSocketMessage(data);
            };

            ws.onerror = (error) => {
                log(`WebSocket error: ${error}`, 'error');
            };

            ws.onclose = () => {
                log('WebSocket disconnected', 'info');
            };
        }

        function handleWebSocketMessage(data) {
            switch(data.type) {
                case 'pong':
                    setTimeout(() => {
                        if (ws && ws.readyState === WebSocket.OPEN) {
                            ws.send(JSON.stringify({ type: 'ping' }));
                        }
                    }, 5000);
                    break;

                case 'word_feedback':
                    processWordFeedback(data.word_feedback);
                    updateAccuracy(data.overall_accuracy);
                    break;

                case 'progress_update':
                    updateProgress(data.progress);
                    break;
            }
        }

        // HELPER FUNCTIONS
        function displaySurahText(surah) {
            const container = document.getElementById('referenceText');
            const words = surah.text.split(' ');

            container.innerHTML = '';
            words.forEach((word, index) => {
                const span = document.createElement('span');
                span.className = 'word';
                span.textContent = word;
                span.dataset.index = index;
                container.appendChild(span);

                if (index < words.length - 1) {
                    container.appendChild(document.createTextNode(' '));
                }
            });
        }

        function processWordFeedback(feedback) {
            feedback.forEach(item => {
                const word = document.querySelector(`.word[data-index="${item.position}"]`);
                if (word) {
                    word.className = `word ${item.color}`;
                }
            });
        }

        function updateAccuracy(accuracy) {
            document.getElementById('accuracyStat').textContent = `${Math.round(accuracy * 100)}%`;
        }

        function updateProgress(progress) {
            document.getElementById('currentWordStat').textContent = progress.current_position;
            document.getElementById('progressFill').style.width = `${progress.progress_percentage}%`;
            document.getElementById('accuracyStat').textContent = `${Math.round(progress.overall_accuracy * 100)}%`;
        }

        function displayAudioFeedback(feedback) {
            const responseDiv = document.getElementById('audioResponse');
            responseDiv.innerHTML = `
                <strong>Audio Feedback:</strong><br>
                Words: ${feedback.word_feedback ? feedback.word_feedback.length : 0}<br>
                Accuracy: ${(feedback.overall_accuracy * 100).toFixed(1)}%<br>
                Position: ${feedback.current_position}<br>
            `;

            if (feedback.word_feedback) {
                processWordFeedback(feedback.word_feedback);
            }
        }

        function applyColorScheme(colors) {
            const style = document.createElement('style');
            style.textContent = `
                .word.correct { background: ${colors.correct} !important; }
                .word.partial { background: ${colors.partial} !important; }
                .word.incorrect { background: ${colors.incorrect} !important; }
                .word.next-expected { background: ${colors.next_expected} !important; }
                .word.current { background: ${colors.current} !important; }
            `;
            document.head.appendChild(style);
        }

        function applyUISettings(settings) {
            document.querySelectorAll('.word').forEach(word => {
                word.style.fontSize = `${settings.font_size}px`;
            });
            applyColorScheme(settings.color_scheme);
        }

        function startSessionTimer() {
            sessionTimer = setInterval(() => {
                const elapsed = Math.floor((Date.now() - sessionStartTime) / 1000);
                const minutes = Math.floor(elapsed / 60);
                const seconds = elapsed % 60;
                document.getElementById('timeStat').textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
            }, 1000);
        }

        function visualizeAudio(stream) {
            const canvas = document.getElementById('audioVisualizer');
            const ctx = canvas.getContext('2d');
            const audioContext = new AudioContext();
            const source = audioContext.createMediaStreamSource(stream);
            const analyser = audioContext.createAnalyser();

            source.connect(analyser);
            analyser.fftSize = 256;

            const bufferLength = analyser.frequencyBinCount;
            const dataArray = new Uint8Array(bufferLength);

            function draw() {
                requestAnimationFrame(draw);
                analyser.getByteFrequencyData(dataArray);

                ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                const barWidth = (canvas.width / bufferLength) * 2.5;
                let x = 0;

                for (let i = 0; i < bufferLength; i++) {
                    const barHeight = (dataArray[i] / 255) * canvas.height;

                    ctx.fillStyle = `rgb(76, ${175 + dataArray[i]/4}, 80)`;
                    ctx.fillRect(x, canvas.height - barHeight, barWidth, barHeight);

                    x += barWidth + 1;
                }
            }

            draw();
        }

        function downloadJSON(data, filename) {
            const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
            downloadBlob(blob, filename);
        }

        function downloadBlob(blob, filename) {
            const url = window.URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.style.display = 'none';
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            window.URL.revokeObjectURL(url);
            document.body.removeChild(a);
        }

        // Latency mode selection
        document.querySelectorAll('.latency-option').forEach(option => {
            option.addEventListener('click', function() {
                document.querySelectorAll('.latency-option').forEach(o => o.classList.remove('active'));
                this.classList.add('active');

                if (currentSessionId) {
                    setFeedbackMode();
                }
            });
        });

        // Initialize on load
        window.addEventListener('DOMContentLoaded', () => {
            log('Page loaded. Initializing API client...', 'info');
            getAllSurahs();
            getUISettings();
            checkHealth();
        });

        // ============= NEW GPT AUDIO ANALYSIS FUNCTIONS =============

        // Function for the dropdown selector
        function setAnalysisMode(mode) {
            switchAnalysisMode(mode);
        }

        // Mode switching function
        function switchAnalysisMode(mode) {
            currentAnalysisMode = mode;

            // Update UI active states
            document.querySelectorAll('.mode-option').forEach(option => {
                option.classList.remove('active');
                if (option.dataset.mode === mode) {
                    option.classList.add('active');
                }
            });

            // Update center panel title and instructions
            const titleEl = document.getElementById('centerPanelTitle');
            const instructionsEl = document.getElementById('modeInstructions');
            const referenceTextEl = document.getElementById('referenceText');
            const referenceInputEl = document.getElementById('referenceTextInput');
            const analysisButtonEl = document.getElementById('analysisButton');
            const languageToggleEl = document.getElementById('languageToggle');
            const surahContextEl = document.getElementById('surahContext');
            const analysisResultsEl = document.getElementById('analysisResults');

            // Reset displays
            referenceInputEl.classList.remove('show');
            analysisButtonEl.classList.remove('show');
            analysisResultsEl.classList.remove('show');
            languageToggleEl.style.display = 'none';
            surahContextEl.style.display = 'none';

            switch(mode) {
                case 'live':
                    titleEl.innerHTML = 'üéôÔ∏è Live Transcription';
                    instructionsEl.innerHTML = '<strong>Live Transcription Mode:</strong> Start a session and begin reciting. Real-time feedback will appear as you speak.';
                    referenceTextEl.style.display = 'block';
                    break;

                case 'tajweed':
                    titleEl.innerHTML = 'üìñ Tajweed Analysis';
                    instructionsEl.innerHTML = '<strong>Tajweed Analysis Mode:</strong> Record or upload your recitation. AI will analyze your Tajweed rules application and provide detailed feedback.';
                    referenceTextEl.style.display = 'none';
                    analysisButtonEl.classList.add('show');
                    languageToggleEl.style.display = 'flex';
                    surahContextEl.style.display = 'block';
                    break;

                case 'recitation':
                    titleEl.innerHTML = '‚úÖ Recitation Accuracy Check';
                    instructionsEl.innerHTML = '<strong>Recitation Accuracy Mode:</strong> Enter the reference text, then record or upload your recitation. AI will check accuracy and provide feedback.';
                    referenceTextEl.style.display = 'none';
                    referenceInputEl.classList.add('show');
                    analysisButtonEl.classList.add('show');
                    languageToggleEl.style.display = 'flex';
                    surahContextEl.style.display = 'block';
                    break;
            }

            log(`Switched to ${mode} mode`, 'info');
        }

        // Language selection function
        function setAnalysisLanguage(lang) {
            analysisLanguage = lang;

            document.querySelectorAll('.language-option').forEach(option => {
                option.classList.remove('active');
                if (option.dataset.lang === lang) {
                    option.classList.add('active');
                }
            });

            log(`Analysis language set to ${lang}`, 'info');
        }

        // Modified recording functions to support all modes
        function toggleRecording() {
            if (isRecording) {
                stopRecording();
            } else {
                startRecording();
            }
        }

        async function startRecording() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });

                if (currentAnalysisMode === 'live' && ws && ws.readyState === WebSocket.OPEN) {
                    // For live mode, use streaming
                    mediaRecorder = new MediaRecorder(stream);

                    mediaRecorder.ondataavailable = (event) => {
                        if (event.data.size > 0 && ws && ws.readyState === WebSocket.OPEN) {
                            // Convert blob to base64 and send as expected format
                            const reader = new FileReader();
                            reader.onload = function() {
                                const base64Audio = reader.result.split(',')[1];
                                ws.send(JSON.stringify({
                                    type: 'audio_chunk',
                                    audio: base64Audio
                                }));
                            };
                            reader.readAsDataURL(event.data);
                        }
                    };

                    mediaRecorder.start(1000); // Send chunks every second
                    visualizeAudio(stream);
                } else {
                    // For GPT modes, collect all audio
                    audioChunks = [];
                    mediaRecorder = new MediaRecorder(stream);

                    mediaRecorder.ondataavailable = (event) => {
                        if (event.data.size > 0) {
                            audioChunks.push(event.data);
                        }
                    };

                    mediaRecorder.onstop = () => {
                        currentAudioBlob = new Blob(audioChunks, { type: 'audio/wav' });
                        log('Recording complete. Audio ready for analysis.', 'success');

                        if (currentAnalysisMode !== 'live') {
                            document.getElementById('analysisButton').style.display = 'block';
                        }
                    };

                    mediaRecorder.start();
                    visualizeAudio(stream);
                }

                isRecording = true;
                document.getElementById('recordBtn').textContent = '‚èπÔ∏è Stop Recording';
                document.getElementById('recordBtn').classList.remove('btn-primary');
                document.getElementById('recordBtn').classList.add('btn-danger');

                log('Recording started', 'success');
            } catch (error) {
                log(`Error starting recording: ${error.message}`, 'error');
            }
        }

        function stopRecording() {
            if (mediaRecorder && mediaRecorder.state !== 'inactive') {
                mediaRecorder.stop();
                mediaRecorder.stream.getTracks().forEach(track => track.stop());

                isRecording = false;
                document.getElementById('recordBtn').textContent = 'üé§ Start Recording';
                document.getElementById('recordBtn').classList.remove('btn-danger');
                document.getElementById('recordBtn').classList.add('btn-primary');

                log('Recording stopped', 'info');
            }
        }

        // Handle file upload
        function uploadAudio() {
            document.getElementById('audioFile').click();
        }

        function handleAudioFile(event) {
            const file = event.target.files[0];
            if (file) {
                currentAudioBlob = file;
                log(`Audio file loaded: ${file.name}`, 'success');

                if (currentAnalysisMode !== 'live') {
                    document.getElementById('analysisButton').style.display = 'block';
                }
            }
        }

        // Main analysis function
        async function performAnalysis() {
            if (!currentAudioBlob) {
                log('No audio available for analysis', 'error');
                return;
            }

            if (currentAnalysisMode === 'tajweed') {
                await analyzeTajweed();
            } else if (currentAnalysisMode === 'recitation') {
                await analyzeRecitation();
            }
        }

        // Tajweed analysis function
        async function analyzeTajweed() {
            log('Starting Tajweed analysis...', 'info');

            const formData = new FormData();
            formData.append('audio_file', currentAudioBlob);
            formData.append('language', analysisLanguage);

            // Add optional context
            const surahName = document.getElementById('contextSurah').value;
            const ayahNumber = document.getElementById('contextAyah').value;

            if (surahName) formData.append('surah_name', surahName);
            if (ayahNumber) formData.append('ayah_number', ayahNumber);

            try {
                const response = await fetch(`${API_BASE}/api/audio/analyze/tajweed`, {
                    method: 'POST',
                    body: formData
                });

                const data = await response.json();

                if (data.success) {
                    displayTajweedResults(data.data);
                    log('Tajweed analysis completed', 'success');
                } else {
                    log(`Analysis failed: ${data.error}`, 'error');
                }
            } catch (error) {
                log(`Error during Tajweed analysis: ${error.message}`, 'error');
            }
        }

        // Recitation analysis function
        async function analyzeRecitation() {
            const referenceText = document.getElementById('referenceTextInput').value.trim();

            if (!referenceText) {
                log('Please enter reference text for recitation checking', 'error');
                return;
            }

            log('Starting recitation accuracy analysis...', 'info');

            const formData = new FormData();
            formData.append('audio_file', currentAudioBlob);
            formData.append('reference_text', referenceText);
            formData.append('language', analysisLanguage);

            // Add optional context
            const surahName = document.getElementById('contextSurah').value;
            const ayahNumber = document.getElementById('contextAyah').value;

            if (surahName) formData.append('surah_name', surahName);
            if (ayahNumber) formData.append('ayah_number', ayahNumber);

            try {
                const response = await fetch(`${API_BASE}/api/audio/analyze/recitation`, {
                    method: 'POST',
                    body: formData
                });

                const data = await response.json();

                if (data.success) {
                    displayRecitationResults(data.data);
                    log('Recitation analysis completed', 'success');
                } else {
                    log(`Analysis failed: ${data.error}`, 'error');
                }
            } catch (error) {
                log(`Error during recitation analysis: ${error.message}`, 'error');
            }
        }

        // Display Tajweed results
        function displayTajweedResults(results) {
            const resultsEl = document.getElementById('analysisResults');
            const contentEl = document.getElementById('analysisContent');

            // Build HTML for results
            let html = '<div class="analysis-section">';

            // Display scores
            if (results.scores) {
                html += '<h4>Tajweed Scores</h4>';
                html += '<div class="scores-grid">';

                const scoreNames = {
                    makharij: 'Makharij',
                    sifat: 'Sifat',
                    ghunnah: 'Ghunnah',
                    madd: 'Madd',
                    noon_rules: 'Noon Rules',
                    overall: 'Overall'
                };

                for (const [key, value] of Object.entries(results.scores)) {
                    const scoreClass = value >= 4 ? 'high' : value >= 3 ? 'medium' : 'low';
                    html += `
                        <div class="score-item">
                            <div class="score-label">${scoreNames[key] || key}</div>
                            <div class="score-value ${scoreClass}">${value.toFixed(1)}</div>
                        </div>
                    `;
                }
                html += '</div>';
            }

            // Display issues
            if (results.issues && results.issues.length > 0) {
                html += '<h4>Issues Found</h4>';
                html += '<ul>';
                results.issues.forEach(issue => {
                    html += `<li>
                        <strong>${issue.rule}</strong> at ${issue.timestamp}s
                        <br>${issue.description}
                        ${issue.correction ? `<br><em>Correction: ${issue.correction}</em>` : ''}
                    </li>`;
                });
                html += '</ul>';
            }

            // Display overall comment
            if (results.overall_comment) {
                html += `<h4>Overall Feedback</h4><p>${results.overall_comment}</p>`;
            }

            // Display next steps
            if (results.next_steps && results.next_steps.length > 0) {
                html += '<h4>Next Steps</h4><ul>';
                results.next_steps.forEach(step => {
                    html += `<li>${step}</li>`;
                });
                html += '</ul>';
            }

            html += '</div>';

            contentEl.innerHTML = html;
            resultsEl.classList.add('show');

            // Handle audio feedback if present
            if (results.audio_feedback) {
                playAudioFeedback(results.audio_feedback);
            }
        }

        // Display Recitation results
        function displayRecitationResults(results) {
            const resultsEl = document.getElementById('analysisResults');
            const contentEl = document.getElementById('analysisContent');

            let html = '<div class="analysis-section">';

            // Display accuracy score
            html += `<h4>Accuracy Score: ${results.accuracy_score.toFixed(1)}%</h4>`;

            // Display errors
            if (results.missed_words && results.missed_words.length > 0) {
                html += `<h4>Missed Words (${results.missed_words.length})</h4>`;
                html += '<ul>';
                results.missed_words.forEach(word => {
                    html += `<li>${word}</li>`;
                });
                html += '</ul>';
            }

            if (results.added_words && results.added_words.length > 0) {
                html += `<h4>Added Words (${results.added_words.length})</h4>`;
                html += '<ul>';
                results.added_words.forEach(word => {
                    html += `<li>${word}</li>`;
                });
                html += '</ul>';
            }

            if (results.mispronounced_words && results.mispronounced_words.length > 0) {
                html += `<h4>Mispronounced Words (${results.mispronounced_words.length})</h4>`;
                html += '<ul>';
                results.mispronounced_words.forEach(item => {
                    html += `<li>${item.word} - ${item.issue}</li>`;
                });
                html += '</ul>';
            }

            // Display feedback
            if (results.feedback) {
                html += `<h4>Feedback</h4><p>${results.feedback}</p>`;
            }

            // Display suggestions
            if (results.suggestions && results.suggestions.length > 0) {
                html += '<h4>Suggestions</h4><ul>';
                results.suggestions.forEach(suggestion => {
                    html += `<li>${suggestion}</li>`;
                });
                html += '</ul>';
            }

            html += '</div>';

            contentEl.innerHTML = html;
            resultsEl.classList.add('show');

            // Handle audio feedback if present
            if (results.audio_feedback) {
                playAudioFeedback(results.audio_feedback);
            }
        }

        // Play audio feedback
        function playAudioFeedback(audioData) {
            if (!audioData || !audioData.audio_base64) return;

            const playerEl = document.getElementById('audioFeedbackPlayer');
            const audioEl = document.getElementById('feedbackAudio');

            // Convert base64 to blob and create URL
            const byteCharacters = atob(audioData.audio_base64);
            const byteNumbers = new Array(byteCharacters.length);
            for (let i = 0; i < byteCharacters.length; i++) {
                byteNumbers[i] = byteCharacters.charCodeAt(i);
            }
            const byteArray = new Uint8Array(byteNumbers);
            const blob = new Blob([byteArray], { type: `audio/${audioData.audio_format || 'wav'}` });
            const audioUrl = URL.createObjectURL(blob);

            audioEl.src = audioUrl;
            playerEl.classList.add('show');

            log('Audio feedback available for playback', 'info');
        }
    </script>
</body>
</html>